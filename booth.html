<!DOCTYPE html>
<html>
  <head>
    <!--script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.5.0/aframe/examples/vendor/aframe/build/aframe.min.js"></script-->
    <script src="https://aframe.io/releases/1.1.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
  <!--script src="https://unpkg.com/aframe-orbit-controls@1.0.0/dist/aframe-orbit-controls.min.js"></script>
    <script src="https://unpkg.com/aframe-orbit-controls@1.2.0/dist/aframe-orbit-controls.min.js"></script> 
  <!--script src="https://unpkg.com/aframe-supercraft-loader@1.1.3/dist/aframe-supercraft-loader.js"></script-->
    <!--script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.5.0/aframe/build/aframe-ar.js"></script-->
<script>
THREE.ShaderLib[ 'zelda-water' ] = {
  vertexShader: [
  '#define SCALE 10.0',
  'varying vec2 vUv;',
  'uniform float timeMsec;',
  'float calculateSurface(float x, float z) {',
  'float uTime = timeMsec / 1000.0;',
'float y = 0.0;',
    'y += (sin(x * 1.0 / SCALE + uTime * 1.0) + sin(x * 2.3 / SCALE + uTime * 1.5) + sin(x * 3.3 / SCALE + uTime * 0.4)) / 3.0;',
    'y += (sin(z * 0.2 / SCALE + uTime * 1.8) + sin(z * 1.8 / SCALE + uTime * 1.8) + sin(z * 2.8 / SCALE + uTime * 0.8)) / 3.0;',
    'return y;',
'}',

'void main() {',
    'float uTime = timeMsec / 1000.0;',
    'vUv = uv;',
   ' vec3 pos = position;', 
    'float strength = 1.0;',
    'pos.y += strength * calculateSurface(pos.x, pos.z);',
    'pos.y -= strength * calculateSurface(0.0, 0.0);',
    'gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);',
'}' 
  ].join( '\n' )
}

  AFRAME.registerShader('makewaves', {
    schema: {
      color: {
        type: 'color',
        is: 'uniform',
        default: '#0051da'
      },
      timeMsec: {
        type: 'time',
        is: 'uniform'
      },
      uMap: {
      type: 'map',
        is: 'uniform'
      }
    },

    vertexShader: THREE.ShaderLib[ 'zelda-water' ].vertexShader ,
    fragmentShader: `
varying vec2 vUv;

uniform sampler2D uMap;

uniform vec3 color;

uniform float timeMsec; 

void main() {
    float uTime = timeMsec / 1000.0;     
    vec2 uv = vUv * 10.0 + vec2(uTime * -0.05);

    uv.y += 0.01 * (sin(uv.x * 3.5 + uTime * 0.35) + sin(uv.x * 4.8 + uTime * 1.05) + sin(uv.x * 7.3 + uTime * 0.45)) / 3.0;
    uv.x += 0.12 * (sin(uv.y * 4.0 + uTime * 0.5) + sin(uv.y * 6.8 + uTime * 0.75) + sin(uv.y * 11.3 + uTime * 0.2)) / 3.0;
    uv.y += 0.12 * (sin(uv.x * 4.2 + uTime * 0.64) + sin(uv.x * 6.3 + uTime * 1.65) + sin(uv.x * 8.2 + uTime * 0.45)) / 3.0;

    vec4 tex1 = texture2D(uMap, uv * 1.0);
    vec4 tex2 = texture2D(uMap, uv * 1.0 + vec2(0.2));

    vec3 blue = color;

    gl_FragColor = vec4(blue + vec3(tex1.a * 0.9 - tex2.a * 0.02), 1.0);

}`
  });

</script>
 <script>
  AFRAME.registerComponent('arjs-portal-door', {
	schema: {
		url : {		// Url of the content - may be video or image
			type: 'string',
		},
		doorWidth : {	// width of the door
			type: 'number',
			default: 1,
		},
		doorHeight : {	// height of the door
			type: 'number',
			default: 2,
		},
	},
	init: function () {
		var _this = this

		var doorWidth = this.data.doorWidth
		var doorHeight = this.data.doorHeight
		var imageURL = this.data.url

		var portalDoor = new THREEx.Portal360(imageURL, doorWidth, doorHeight)
		this._portalDoor = portalDoor

		this.el.object3D.add(portalDoor.object3d)
	},
	tick: function(){
		this._portalDoor.update()
	}
})


AFRAME.registerPrimitive('a-portal-door', AFRAME.utils.extendDeep({}, AFRAME.primitives.getMeshMixin(), {
	defaultComponents: {
		'arjs-portal-door': {},
	},
	mappings: {
		'url': 'arjs-portal-door.url',
	}
}))
</script>
<script>
var THREEx = THREEx || {}

THREEx.Portal360 = function(videoImageURL, doorWidth, doorHeight){
	
	var doorCenter = new THREE.Group
	doorCenter.position.y = doorHeight/2
	this.object3d = doorCenter

	//////////////////////////////////////////////////////////////////////////////
	//		build texture360
	//////////////////////////////////////////////////////////////////////////////
	var isVideo = videoImageURL.match(/.(mp4|webm|ogv)/i) ? true : false
	if( isVideo ){
		var video = document.createElement( 'video' )
		video.width = 640;
		video.height = 360;
		video.loop = true;
		video.muted = true;
		video.src = videoImageURL;
		video.crossOrigin = 'anonymous'
		video.setAttribute( 'webkit-playsinline', 'webkit-playsinline' );
		video.play();

		var texture360 = new THREE.VideoTexture( video );
		texture360.minFilter = THREE.LinearFilter;
		texture360.format = THREE.RGBFormat;	
		texture360.flipY = false;		
	}else{
		var texture360 = new THREE.TextureLoader().load(videoImageURL)
		texture360.minFilter = THREE.NearestFilter;
		texture360.format = THREE.RGBFormat;
		texture360.flipY = false;		
	}

	//////////////////////////////////////////////////////////////////////////////
	//		build mesh
	//////////////////////////////////////////////////////////////////////////////

	// create insideMesh which is visible IIF inside the portal
	var insideMesh = this._buildInsideMesh(texture360, doorWidth, doorHeight)
	doorCenter.add(insideMesh)
	this.insideMesh = insideMesh

	// create outsideMesh which is visible IIF outside the portal
	var outsideMesh = this._buildOutsideMesh(texture360, doorWidth, doorHeight)
	doorCenter.add(outsideMesh)
	this.outsideMesh = outsideMesh

	// create frameMesh for the frame of the portal
	var frameMesh = this._buildRectangularFrame(doorWidth/100, doorWidth, doorHeight)
	doorCenter.add(frameMesh)
}
//////////////////////////////////////////////////////////////////////////////
//		Code Separator
//////////////////////////////////////////////////////////////////////////////
THREEx.Portal360.buildTransparentMaterial = function(){
	// if there is a cached version, return it
	if( THREEx.Portal360.buildTransparentMaterial.material ){
		return THREEx.Portal360.buildTransparentMaterial.material
	}
	var material = new THREE.MeshBasicMaterial({
		colorWrite: false // only write to z-buf
	})
	// an alternative to reach the same visual - this one seems way slower tho. My guess is it is hitting a slow-path in gpu
	// var material   = new THREE.MeshBasicMaterial();
	// material.color.set('black')
	// material.opacity   = 0;
	// material.blending  = THREE.NoBlending;
	
	// cache the material
	THREEx.Portal360.buildTransparentMaterial.material = material
	
	return material		
}

//////////////////////////////////////////////////////////////////////////////
//		Build various cache
//////////////////////////////////////////////////////////////////////////////
THREEx.Portal360.buildSquareCache = function(){
	var container = new THREE.Group
	// add outter cube - invisibility cloak
	var geometry = new THREE.PlaneGeometry(50,50);
	var material = THREEx.Portal360.buildTransparentMaterial()

	var mesh = new THREE.Mesh( geometry, material);
	mesh.position.x =  geometry.parameters.width/2 + 0.5
	mesh.position.y = -geometry.parameters.height/2 + 0.5
	container.add(mesh)
	
	var mesh = new THREE.Mesh( geometry, material);
	mesh.position.x = -geometry.parameters.width/2 + 0.5
	mesh.position.y = -geometry.parameters.height/2 - 0.5
	container.add(mesh)
	
	var mesh = new THREE.Mesh( geometry, material);
	mesh.position.x = -geometry.parameters.width/2 - 0.5
	mesh.position.y =  geometry.parameters.height/2 - 0.5
	container.add(mesh)
	
	var mesh = new THREE.Mesh( geometry, material);
	mesh.position.x = +geometry.parameters.width/2 - 0.5
	mesh.position.y =  geometry.parameters.height/2 + 0.5
	container.add(mesh)

	return container
}

//////////////////////////////////////////////////////////////////////////////
//		build meshes
//////////////////////////////////////////////////////////////////////////////

/**
 * create insideMesh which is visible IIF inside the portal
 */
THREEx.Portal360.prototype._buildInsideMesh	= function(texture360, doorWidth, doorHeight){
	var doorInsideCenter = new THREE.Group

	// var squareCache = THREEx.Portal360.buildSquareCache()
	// squareCache.scale.y = doorWidth
	// squareCache.scale.y = doorHeight
	// doorInsideCenter.add( squareCache )

	var geometry = new THREE.PlaneGeometry(doorWidth, doorHeight)
	var material = THREEx.Portal360.buildTransparentMaterial()
	// var material = new THREE.MeshNormalMaterial()
	var mesh = new THREE.Mesh( geometry, material)
	mesh.rotation.y = Math.PI
	// mesh.position.z = 0.03
	doorInsideCenter.add( mesh )


	//////////////////////////////////////////////////////////////////////////////
	//		add 360 sphere
	//////////////////////////////////////////////////////////////////////////////
	// add 360 texture
	// TODO put that in a this.data
	var radius360Sphere = 100
	// var radius360Sphere = 1

	var geometry = new THREE.SphereGeometry( radius360Sphere, 16, 16).rotateZ(Math.PI)
	var material = new THREE.MeshBasicMaterial( {
		map: texture360,
		// opacity: 0.9,
		side: THREE.DoubleSide,
	});
	var material = new THREE.MeshNormalMaterial()
	var sphere360Mesh = new THREE.Mesh( geometry, material );
	sphere360Mesh.position.z = 0.5
	sphere360Mesh.rotation.y = Math.PI
	doorInsideCenter.add(sphere360Mesh)
	
	return doorInsideCenter
}

/**
 * create outsideMesh which is visible IIF outside the portal
 */
 
THREEx.Portal360.prototype._buildOutsideMesh = function(texture360, doorWidth, doorHeight){
	var doorOutsideCenter = new THREE.Group

	//////////////////////////////////////////////////////////////////////////////
	//		add squareCache
	//////////////////////////////////////////////////////////////////////////////
	var squareCache = THREEx.Portal360.buildSquareCache()
	squareCache.scale.y = doorWidth
	squareCache.scale.y = doorHeight
	doorOutsideCenter.add( squareCache )

	//////////////////////////////////////////////////////////////////////////////
	//		add 360 sphere
	//////////////////////////////////////////////////////////////////////////////
	// add 360 texture
	var radius360Sphere = 100
	// var radius360Sphere = 1

	// build half sphere geometry
	var geometry = new THREE.SphereGeometry( radius360Sphere, 160, 160, Math.PI, Math.PI, 0, Math.PI).rotateZ(Math.PI)
	// fix UVs
	geometry.faceVertexUvs[0].forEach(function(faceUvs){
		faceUvs.forEach(function(uv){
			uv.x /= 2
		})
	})
	geometry.uvsNeedUpdate = true
	var material = new THREE.MeshBasicMaterial( {
		map: texture360,
		//opacity: 0.9,
		side: THREE.BackSide,
	});
	// var geometry = new THREE.SphereGeometry( radius360Sphere, 16, 16);
	var material = new THREE.MeshNormalMaterial()
	var sphere360Mesh = new THREE.Mesh( geometry, material );
	sphere360Mesh.position.z = -0.1
	doorOutsideCenter.add(sphere360Mesh)
	
	return doorOutsideCenter
}

/**
 * create frameMesh for the frame of the portal
 */
THREEx.Portal360.prototype._buildRectangularFrame = function(radius, width, height){
	var container = new THREE.Group
	var material = new THREE.MeshNormalMaterial()
	var material = new THREE.MeshPhongMaterial({
		color: 'silver',
		emissive: 'white'
	})

	var geometryBeamVertical = new THREE.CylinderGeometry(radius, radius, height - radius)

	// mesh right
	var meshRight = new THREE.Mesh(geometryBeamVertical, material)
	meshRight.position.x = width/2
	container.add(meshRight)

	// mesh right
	var meshLeft = new THREE.Mesh(geometryBeamVertical, material)
	meshLeft.position.x = -width/2
	container.add(meshLeft)

	var geometryBeamHorizontal = new THREE.CylinderGeometry(radius, radius, width - radius).rotateZ(Math.PI/2)

	// mesh top
	var meshTop = new THREE.Mesh(geometryBeamHorizontal, material)
	meshTop.position.y = height/2
	container.add(meshTop)

	// mesh bottom
	var meshBottom = new THREE.Mesh(geometryBeamHorizontal, material)
	meshBottom.position.y = -height/2
	container.add(meshBottom)

	return container
}	

//////////////////////////////////////////////////////////////////////////////
//		update function
//////////////////////////////////////////////////////////////////////////////

THREEx.Portal360.prototype.update = function () {
	// determine if the user is isOutsidePortal
	var localPosition = new THREE.Vector3
	this.object3d.worldToLocal(localPosition)
	var isOutsidePortal = localPosition.z >= -5 ? true : false

	// handle mesh visibility based on isOutsidePortal
	if( isOutsidePortal ){
		this.outsideMesh.visible = true
		this.insideMesh.visible = true
	}else{
		this.outsideMesh.visible = false
		this.insideMesh.visible = false
	}
}

</script>

    
  </head>
  <body style="margin : 0px; overflow: hidden;">
    <!-- Create a anchor to attach your augmented reality -->
    <a-scene 
             cursor="rayOrigin: mouse"
             embedded arjs="trackingMethod: best;"
    >
      
      <a-assets>
        <a-asset-item id="ballModel" src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fjini-ball.glb?v=1617066080111"></a-asset-item>
        <a-asset-item id="ballModel1" src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fdragon_ball.glb?v=1617260215509"></a-asset-item>
        <a-asset-item
          id="booth"
          src="https://cdn.glitch.com/1072d99f-9af1-440e-a602-7dad12185289%2Fexhibition-booth.glb?v=1616062180247"
        ></a-asset-item>
        <a-asset-item
          id="booth1"
          src="https://cdn.glitch.com/1072d99f-9af1-440e-a602-7dad12185289%2Fphotography_exhibition.glb?v=1616112161824"
        ></a-asset-item>
        <a-asset-item
          id="booth2"
          src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fhexadome.glb?v=1618012654623"
        ></a-asset-item>
      </a-assets>

   <!--a-entity camera look-controls orbit-controls="target: 0 0 0; minDistance: 10; maxDistance: 100; initialPosition: 0.2 0.2 -22"></a-entity-->
<a-entity camera look-controls orbit-controls="target: 0 0 0; minDistance: 100; maxDistance: 1000; initialPosition: 0 1.6 -30"></a-entity>
      <!-- portal 360 with an image -->
      <!-- <a-portal-door url='images/360_topaz.png' position='0 0 0' scale='1 1 1' rotation='0 90 0'><a-portal-door> -->

      <!-- portal 360 with an video -->
      <!--<a-portal-door url='videos/pano.webm' position='0 0 0' scale='2 2 2' rotation='0 90 0'><a-portal-door>-->
      <a-portal-door
        hit-testing-enabled="true"
        url="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2F360_topaz.png?v=1617066095563"
        position="0 1.2 -30.5"
        scale="10 10 10"
        rotation="0 180 0"
      >
      </a-portal-door>
      <a-sky src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2F360_topaz.png?v=1617066095563"></a-sky>
      <a-box scale="20 0.1 40" position="0 -0.5 -4.5" color="#8083A2" shadow="receive: true"></a-box>
            <!--a-entity
        navigate-on-click="url: https://famous-actually-mint.glitch.me/"
        gltf-model="#booth"
        id="feel1"
        position="-2 -0.5 -8.7"
        rotation="0 -90 0"
        scale=".02 .02 .02"
        animation-mixer="loop: true"
                      shadow="receive: true"
      >
      </a-entity>
            <a-entity
        navigate-on-click="url: https://famous-actually-mint.glitch.me/"
        gltf-model="#booth1"
        id="feel2"
        position="-4 -0.4 10"
        rotation="0 180 0"
        scale=".02 .02 .02"
        animation-mixer="loop: true"
                      shadow="receive: true"
      >
      </a-entity-->
    
            <!--a-entity
        navigate-on-click="url: https://famous-actually-mint.glitch.me/"
        gltf-model="#booth2"
        id="feel3"
        position="-2 3.5 -4.7"
        rotation="0 180 0"
        scale=".02 .02 .02"
        animation-mixer="loop: true"
                      shadow="receive: true"
      >
      </a-entity-->
      <!--a-plane
        position="0 -0.8 -2"
        width="50" 
        height="50"
        rotation="90 0 0"
        color="blue"
      ></a-plane-->

      <a-entity
      hit-testing-enabled="true"
      id="ball1"
      scale="1 1 1"
      position="0 1.9 4"
      gltf-model="#ballModel1"
      shadow="receive: true">
      </a-entity>
      <a-entity
      hit-testing-enabled="true"
      id="ball"
      scale="5 5 5"
      position="0 1.5 -6"
      gltf-model="#ballModel"
      shadow="receive: true">
      </a-entity>
      <a-entity light="type: ambient; intensity: 0.55;"></a-entity>    
        <a-light
        type="directional"
        light="castShadow: true;
                      shadowMapHeight: 1024;
                      shadowMapWidth: 1024;
                      shadowCameraLeft: -7;
                      shadowCameraRight: 5;
                      shadowCameraBottom: -5;
                      shadowCameraTop: 5;"
        id="light"
        target="dino"
        position="-1.8 4 1"
      >
      </a-light>
      <!--a-entity light="type:directional; castShadow:true; intensity: 0.65;" position="1 1 1"></a-entity-->

      <!--a-sky src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2F360_topaz.png?v=1617066095563"></a-sky-->




      <!--a-entity id="player" camera="active: true" look-controls wasd-controls position="0 1.6 0"></a-entity-->
      <!-- Define a static camera -->
      <a-camera></a-camera>
      <!--a-camera-static /-->
    </a-scene>

  </body>
</html>
