<!DOCTYPE html>
<html>
  <head>
    <!--script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.5.0/aframe/examples/vendor/aframe/build/aframe.min.js"></script-->
    <script src="https://aframe.io/releases/1.1.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <!--script src="https://unpkg.com/aframe-orbit-controls@1.0.0/dist/aframe-orbit-controls.min.js"></script-->
    <script src="https://unpkg.com/aframe-orbit-controls@1.2.0/dist/aframe-orbit-controls.min.js"></script>
    <!--script src="https://unpkg.com/aframe-supercraft-loader@1.1.3/dist/aframe-supercraft-loader.js"></script-->
    <!--script src="https://cdn.rawgit.com/jeromeetienne/AR.js/1.5.0/aframe/build/aframe-ar.js"></script-->
    <script src="//cdn.rawgit.com/donmccurdy/aframe-extras/v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component/dist/aframe-event-set-component.min.js"></script>
    <script>
      AFRAME.registerComponent("arjs-portal-door", {
        schema: {
          url: {
            // Url of the content - may be video or image
            type: "string"
          },
          doorWidth: {
            // width of the door
            type: "number",
            default: 1
          },
          doorHeight: {
            // height of the door
            type: "number",
            default: 2
          }
        },
        init: function() {
          var _this = this;

          var doorWidth = this.data.doorWidth;
          var doorHeight = this.data.doorHeight;
          var imageURL = this.data.url;

          var portalDoor = new THREEx.Portal360(
            imageURL,
            doorWidth,
            doorHeight
          );
          this._portalDoor = portalDoor;

          this.el.object3D.add(portalDoor.object3d);
        },
        tick: function() {
          this._portalDoor.update();
        }
      });

      AFRAME.registerPrimitive(
        "a-portal-door",
        AFRAME.utils.extendDeep({}, AFRAME.primitives.getMeshMixin(), {
          defaultComponents: {
            "arjs-portal-door": {}
          },
          mappings: {
            url: "arjs-portal-door.url"
          }
        })
      );
    </script>
    <script>
      var THREEx = THREEx || {};

      THREEx.Portal360 = function(videoImageURL, doorWidth, doorHeight) {
        var doorCenter = new THREE.Group();
        doorCenter.position.y = doorHeight / 2;
        this.object3d = doorCenter;

        //////////////////////////////////////////////////////////////////////////////
        //		build texture360
        //////////////////////////////////////////////////////////////////////////////
        var isVideo = videoImageURL.match(/.(mp4|webm|ogv)/i) ? true : false;
        if (isVideo) {
          var video = document.createElement("video");
          video.width = 640;
          video.height = 360;
          video.loop = true;
          video.muted = true;
          video.src = videoImageURL;
          video.crossOrigin = "anonymous";
          video.setAttribute("webkit-playsinline", "webkit-playsinline");
          video.play();

          var texture360 = new THREE.VideoTexture(video);
          texture360.minFilter = THREE.LinearFilter;
          texture360.format = THREE.RGBFormat;
          texture360.flipY = false;
        } else {
          var texture360 = new THREE.TextureLoader().load(videoImageURL);
          texture360.minFilter = THREE.NearestFilter;
          texture360.format = THREE.RGBFormat;
          texture360.flipY = false;
        }

        //////////////////////////////////////////////////////////////////////////////
        //		build mesh
        //////////////////////////////////////////////////////////////////////////////

        // create insideMesh which is visible IIF inside the portal
        var insideMesh = this._buildInsideMesh(
          texture360,
          doorWidth,
          doorHeight
        );
        doorCenter.add(insideMesh);
        this.insideMesh = insideMesh;

        // create outsideMesh which is visible IIF outside the portal
        var outsideMesh = this._buildOutsideMesh(
          texture360,
          doorWidth,
          doorHeight
        );
        doorCenter.add(outsideMesh);
        this.outsideMesh = outsideMesh;

        // create frameMesh for the frame of the portal
        var frameMesh = this._buildRectangularFrame(
          doorWidth / 100,
          doorWidth,
          doorHeight
        );
        doorCenter.add(frameMesh);
      };
      //////////////////////////////////////////////////////////////////////////////
      //		Code Separator
      //////////////////////////////////////////////////////////////////////////////
      THREEx.Portal360.buildTransparentMaterial = function() {
        // if there is a cached version, return it
        if (THREEx.Portal360.buildTransparentMaterial.material) {
          return THREEx.Portal360.buildTransparentMaterial.material;
        }
        var material = new THREE.MeshBasicMaterial({
          colorWrite: false // only write to z-buf
        });
        // an alternative to reach the same visual - this one seems way slower tho. My guess is it is hitting a slow-path in gpu
        // var material   = new THREE.MeshBasicMaterial();
        // material.color.set('black')
        // material.opacity   = 0;
        // material.blending  = THREE.NoBlending;

        // cache the material
        THREEx.Portal360.buildTransparentMaterial.material = material;

        return material;
      };

      //////////////////////////////////////////////////////////////////////////////
      //		Build various cache
      //////////////////////////////////////////////////////////////////////////////
      THREEx.Portal360.buildSquareCache = function() {
        var container = new THREE.Group();
        // add outter cube - invisibility cloak
        var geometry = new THREE.PlaneGeometry(50, 50);
        var material = THREEx.Portal360.buildTransparentMaterial();

        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = geometry.parameters.width / 2 + 0.5;
        mesh.position.y = -geometry.parameters.height / 2 + 0.5;
        container.add(mesh);

        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = -geometry.parameters.width / 2 + 0.5;
        mesh.position.y = -geometry.parameters.height / 2 - 0.5;
        container.add(mesh);

        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = -geometry.parameters.width / 2 - 0.5;
        mesh.position.y = geometry.parameters.height / 2 - 0.5;
        container.add(mesh);

        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = +geometry.parameters.width / 2 - 0.5;
        mesh.position.y = geometry.parameters.height / 2 + 0.5;
        container.add(mesh);

        return container;
      };

      //////////////////////////////////////////////////////////////////////////////
      //		build meshes
      //////////////////////////////////////////////////////////////////////////////

      /**
       * create insideMesh which is visible IIF inside the portal
       */
      THREEx.Portal360.prototype._buildInsideMesh = function(
        texture360,
        doorWidth,
        doorHeight
      ) {
        var doorInsideCenter = new THREE.Group();

        // var squareCache = THREEx.Portal360.buildSquareCache()
        // squareCache.scale.y = doorWidth
        // squareCache.scale.y = doorHeight
        // doorInsideCenter.add( squareCache )

        var geometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
        var material = THREEx.Portal360.buildTransparentMaterial();
        // var material = new THREE.MeshNormalMaterial()
        var mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.y = Math.PI;
        // mesh.position.z = 0.03
        doorInsideCenter.add(mesh);

        //////////////////////////////////////////////////////////////////////////////
        //		add 360 sphere
        //////////////////////////////////////////////////////////////////////////////
        // add 360 texture
        // TODO put that in a this.data
        var radius360Sphere = 100;
        // var radius360Sphere = 1

        var geometry = new THREE.SphereGeometry(
          radius360Sphere,
          16,
          16
        ).rotateZ(Math.PI);
        var material = new THREE.MeshBasicMaterial({
          map: texture360,
          // opacity: 0.9,
          side: THREE.DoubleSide
        });
        var material = new THREE.MeshNormalMaterial();
        var sphere360Mesh = new THREE.Mesh(geometry, material);
        sphere360Mesh.position.z = 0.5;
        sphere360Mesh.rotation.y = Math.PI;
        doorInsideCenter.add(sphere360Mesh);

        return doorInsideCenter;
      };

      /**
       * create outsideMesh which is visible IIF outside the portal
       */

      THREEx.Portal360.prototype._buildOutsideMesh = function(
        texture360,
        doorWidth,
        doorHeight
      ) {
        var doorOutsideCenter = new THREE.Group();

        //////////////////////////////////////////////////////////////////////////////
        //		add squareCache
        //////////////////////////////////////////////////////////////////////////////
        var squareCache = THREEx.Portal360.buildSquareCache();
        squareCache.scale.y = doorWidth;
        squareCache.scale.y = doorHeight;
        doorOutsideCenter.add(squareCache);

        //////////////////////////////////////////////////////////////////////////////
        //		add 360 sphere
        //////////////////////////////////////////////////////////////////////////////
        // add 360 texture
        var radius360Sphere = 100;
        // var radius360Sphere = 1

        // build half sphere geometry
        var geometry = new THREE.SphereGeometry(
          radius360Sphere,
          160,
          160,
          Math.PI,
          Math.PI,
          0,
          Math.PI
        ).rotateZ(Math.PI);
        // fix UVs
        geometry.faceVertexUvs[0].forEach(function(faceUvs) {
          faceUvs.forEach(function(uv) {
            uv.x /= 2;
          });
        });
        geometry.uvsNeedUpdate = true;
        var material = new THREE.MeshBasicMaterial({
          map: texture360,
          //opacity: 0.9,
          side: THREE.BackSide
        });
        // var geometry = new THREE.SphereGeometry( radius360Sphere, 16, 16);
        var material = new THREE.MeshNormalMaterial();
        var sphere360Mesh = new THREE.Mesh(geometry, material);
        sphere360Mesh.position.z = -0.1;
        doorOutsideCenter.add(sphere360Mesh);

        return doorOutsideCenter;
      };

      /**
       * create frameMesh for the frame of the portal
       */
      THREEx.Portal360.prototype._buildRectangularFrame = function(
        radius,
        width,
        height
      ) {
        var container = new THREE.Group();
        var material = new THREE.MeshNormalMaterial();
        var material = new THREE.MeshPhongMaterial({
          color: "silver",
          emissive: "white"
        });

        var geometryBeamVertical = new THREE.CylinderGeometry(
          radius,
          radius,
          height - radius
        );

        // mesh right
        var meshRight = new THREE.Mesh(geometryBeamVertical, material);
        meshRight.position.x = width / 2;
        container.add(meshRight);

        // mesh right
        var meshLeft = new THREE.Mesh(geometryBeamVertical, material);
        meshLeft.position.x = -width / 2;
        container.add(meshLeft);

        var geometryBeamHorizontal = new THREE.CylinderGeometry(
          radius,
          radius,
          width - radius
        ).rotateZ(Math.PI / 2);

        // mesh top
        var meshTop = new THREE.Mesh(geometryBeamHorizontal, material);
        meshTop.position.y = height / 2;
        container.add(meshTop);

        // mesh bottom
        var meshBottom = new THREE.Mesh(geometryBeamHorizontal, material);
        meshBottom.position.y = -height / 2;
        container.add(meshBottom);

        return container;
      };

      //////////////////////////////////////////////////////////////////////////////
      //		update function
      //////////////////////////////////////////////////////////////////////////////

      THREEx.Portal360.prototype.update = function() {
        // determine if the user is isOutsidePortal
        var localPosition = new THREE.Vector3();
        this.object3d.worldToLocal(localPosition);
        var isOutsidePortal = localPosition.z >= -5 ? true : false;

        // handle mesh visibility based on isOutsidePortal
        if (isOutsidePortal) {
          this.outsideMesh.visible = true;
          this.insideMesh.visible = true;
        } else {
          this.outsideMesh.visible = false;
          this.insideMesh.visible = false;
        }
      };
    </script>
    <script>
      THREE.ShaderLib["zelda-water"] = {
        vertexShader: [
          "#define SCALE 10.0",
          "varying vec2 vUv;",
          "uniform float timeMsec;",
          "float calculateSurface(float x, float z) {",
          "float uTime = timeMsec / 1000.0;",
          "float y = 0.0;",
          "y += (sin(x * 1.0 / SCALE + uTime * 1.0) + sin(x * 2.3 / SCALE + uTime * 1.5) + sin(x * 3.3 / SCALE + uTime * 0.4)) / 3.0;",
          "y += (sin(z * 0.2 / SCALE + uTime * 1.8) + sin(z * 1.8 / SCALE + uTime * 1.8) + sin(z * 2.8 / SCALE + uTime * 0.8)) / 3.0;",
          "return y;",
          "}",

          "void main() {",
          "float uTime = timeMsec / 1000.0;",
          "vUv = uv;",
          " vec3 pos = position;",
          "float strength = 1.0;",
          "pos.y += strength * calculateSurface(pos.x, pos.z);",
          "pos.y -= strength * calculateSurface(0.0, 0.0);",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);",
          "}"
        ].join("\n")
      };

      AFRAME.registerShader("makewaves", {
        schema: {
          color: {
            type: "color",
            is: "uniform",
            default: "#0051da"
          },
          timeMsec: {
            type: "time",
            is: "uniform"
          },
          uMap: {
            type: "map",
            is: "uniform"
          }
        },

        vertexShader: THREE.ShaderLib["zelda-water"].vertexShader,
        fragmentShader: `
varying vec2 vUv;

uniform sampler2D uMap;

uniform vec3 color;

uniform float timeMsec; 

void main() {
    float uTime = timeMsec / 1000.0;     
    vec2 uv = vUv * 10.0 + vec2(uTime * -0.05);

    uv.y += 0.01 * (sin(uv.x * 3.5 + uTime * 0.35) + sin(uv.x * 4.8 + uTime * 1.05) + sin(uv.x * 7.3 + uTime * 0.45)) / 3.0;
    uv.x += 0.12 * (sin(uv.y * 4.0 + uTime * 0.5) + sin(uv.y * 6.8 + uTime * 0.75) + sin(uv.y * 11.3 + uTime * 0.2)) / 3.0;
    uv.y += 0.12 * (sin(uv.x * 4.2 + uTime * 0.64) + sin(uv.x * 6.3 + uTime * 1.65) + sin(uv.x * 8.2 + uTime * 0.45)) / 3.0;

    vec4 tex1 = texture2D(uMap, uv * 1.0);
    vec4 tex2 = texture2D(uMap, uv * 1.0 + vec2(0.2));

    vec3 blue = color;

    gl_FragColor = vec4(blue + vec3(tex1.a * 0.9 - tex2.a * 0.02), 1.0);

}`
      });
    </script>
  </head>
  <body style="margin : 0px; overflow: hidden;">
    <!-- Create a anchor to attach your augmented reality -->

    <a-scene
      embedded
      arjs="trackingMethod: best;"
      cursor="rayOrigin: mouse"
      cursor-modifier
      raycaster="objects: .clickable"
      vr-mode-ui="enabled: false;"
    >
      <a-assets>
        <a-asset-item
          id="ballModel"
          src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fapollo_11_command.glb?v=1618360112736"
        ></a-asset-item>
        <a-asset-item
          id="ballModel1"
          src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fastronautwalking.glb?v=1618159443179"
        ></a-asset-item>
        <a-asset-item
          id="booth"
          src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fwhale-animated.glb?v=1618325189173"
        ></a-asset-item>
        <a-asset-item
          id="booth1"
          src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Ffish-ship.glb?v=1618325183480"
        ></a-asset-item>
        <a-asset-item
          id="booth2"
          src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Ftruth_about_the_dark_side_of_the_moon.glb?v=1618361453348"
        ></a-asset-item>
        <!--img
          id="texture"
          src="https://ankit-profile-storage.s3.ap-south-1.amazonaws.com/blog/wood-texture.jpg"
        /-->
      </a-assets>

      <a-entity
        camera
        look-controls
        orbit-controls="target: 0 0 0; minDistance: 10; maxDistance: 100; initialPosition: 0.2 0.2 -22"
      ></a-entity>

      <!-- portal 360 with an image -->
      <!-- <a-portal-door url='images/360_topaz.png' position='0 0 0' scale='1 1 1' rotation='0 90 0'><a-portal-door> -->

      <!-- portal 360 with an video -->
      <!--<a-portal-door url='videos/pano.webm' position='0 0 0' scale='2 2 2' rotation='0 90 0'><a-portal-door>-->
      <a-portal-door
        hit-testing-enabled="true"
        url="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2F360_topaz.png?v=1617066095563"
        position="0 -1.2 -2.5"
        scale="5 5 5"
        rotation="0 180 0"
      >
      </a-portal-door>
      <!--a-sky
        src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2Fseaview-360.jpg?v=1618331535457"
      ></a-sky-->
      <a-sphere
        id="redball"
        scale="0 0 0"
        material="color: red"
        radius="1"
        position="0 -0.5 -5"
        animation__scale="property: scale; dir: alternate; dur: 2000;
                           easing: easeInSine; loop: true; to: 1.2 1 1.2"
      >
      </a-sphere>
      <a-sphere
        color="#C73D6D"
        radius="0.5"
        animation="property: position; to: 0 1.5 0; dur: 700; loop: true; easing: easeInSine; dir: alternate"
        animation__color="property: color; to: #58303E; dur: 700; loop: true; easing: easeInSine; dir: alternate"
      ></a-sphere>
      <a-box
        width="1"
        height="1"
        depth="0.5"
        color="#58303E"
        position="1.1 0 0"
        animation="property: rotation; to: 180 0 0; dur: 1500; loop: true; easing: linear"
      ></a-box>
      <a-box
        width="1"
        height="0.5"
        depth="0.5"
        color="#A28886"
        src="#texture"
        position="1.1 1 0"
        animation="property: rotation; to: 180 0 0; dur: 5000; loop: true; easing: linear"
      ></a-box>
      <!--a-box
        scale="20 0.1 40"
        position="0 -0.5 -4.5"
        color="#8083A2"
        shadow="receive: true"
      ></a-box-->
      <a-entity
        navigate-on-click="url: https://famous-actually-mint.glitch.me/"
        gltf-model="#booth"
        id="feel1"
        position="-2 -0.5 8.7"
        rotation="2 -90 0"
        scale="5.5 5.5 5.5"
        animation-mixer="loop: false"
        shadow="receive: true"
        animation="property: position; to: 15 0.5 10; dur: 7000; loop: true; easing: easeInSine; dir: alternate"
      >
      </a-entity>
      <a-entity
        navigate-on-click="url: https://famous-actually-mint.glitch.me/"
        gltf-model="#booth1"
        id="feel2"
        position="-5 1.4 10"
        rotation="0 130 0"
        scale=".02 .02 .02"
        animation-mixer="loop: false"
        shadow="receive: true"
       >
      </a-entity>

      <a-entity
        navigate-on-click="url: https://famous-actually-mint.glitch.me/"
        gltf-model="#booth2"
        id="feel3"
        position="-2 50.5 250.7"
        rotation="0 45 45"
        scale="0.2 0.2 0.2"
        animation-mixer="loop: false"
        shadow="receive: true"
        animation="property: rotation; to: 0 360 0; loop: true; dur: 10000"
      >
      </a-entity>
      <!--a-plane
        position="0 -0.8 -2"
        width="50" 
        height="50"
        rotation="90 0 0"
        color="blue"
      ></a-plane-->

      <a-entity
        hit-testing-enabled="true"
        id="ball1"
        scale="0.5 0.5 0.5"
        position="0 10.9 -10"
        gltf-model="#ballModel1"
        shadow="receive: true"
        animation-mixer="loop: false"
        animation="property: position; to: 0 5.9 5; dur: 20000; easing: linear; loop: false"
        animation__2="property: position; to: 2 0.7 21; dur: 20000; easing: linear; loop: false"
      >
      </a-entity>
      <a-entity
        hit-testing-enabled="true"
        id="ball"
        scale="0.03 0.03 0.03"
        position="5 -3.5 -25"
        roatation="0 90 0"
        gltf-model="#ballModel"
        shadow="receive: true"
        animation-mixer="loop: false"
        animation="property: rotation; to: 0 360 0; loop: true; dur: 30000"
      >
      </a-entity>
      <a-plane
        rotation="-90 0 0"
        postion="0 -400 -300"
        width="450"
        height="150"
        segments-height="20"
        segments-width="20"
        material="shader:makewaves; uMap: https://cinemont.com/tutorials/zelda/water.png; repeat: 50 50;"
        shadow="receive: true"
      ></a-plane>

      <a-entity light="type: ambient; intensity: 0.55;"></a-entity>
      <a-light
        type="directional"
        light="castShadow: true;
                      shadowMapHeight: 1024;
                      shadowMapWidth: 1024;
                      shadowCameraLeft: -7;
                      shadowCameraRight: 5;
                      shadowCameraBottom: -5;
                      shadowCameraTop: 5;"
        id="light"
        target="dino"
        position="-1.8 4 1"
      >
      </a-light>
      <!--a-entity light="type:directional; castShadow:true; intensity: 0.65;" position="1 1 1"></a-entity-->

      <!--a-sky src="https://cdn.glitch.com/3d3ecbaf-67a2-4d22-b8ec-ad23b8be5288%2F360_topaz.png?v=1617066095563"></a-sky-->

      <!--a-entity id="player" camera="active: true" look-controls wasd-controls position="0 1.6 0"></a-entity-->
      <!-- Define a static camera -->
      <!--a-camera></a-camera-->
      <!--a-camera-static /-->
    </a-scene>
    <script>
    // `click` event emitted by browser on mouse click.
document.querySelector('redball').addEventListener('click', function (evt) {
  console.log('This 2D element was clicked!');
});</script>
    <!--script>
      /**
       * Click the scene to start/stop the bouncing.
       */

      var bouncing = false;
      document.addEventListener("click", function() {
        bouncing = !bouncing;
        var el = document.querySelector("#redball");
        el.emit(bouncing ? "bounce-start" : "bounce-stop");
      });
    </script-->
    <!--script>
      window.human = false;

      var canvasEl = document.querySelector(".fireworks");
      var ctx = canvasEl.getContext("2d");
      var numberOfParticules = 30;
      var pointerX = 0;
      var pointerY = 0;
      var tap =
        "ontouchstart" in window || navigator.msMaxTouchPoints
          ? "touchstart"
          : "mousedown";
      var colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"];

      function setCanvasSize() {
        canvasEl.width = window.innerWidth * 2;
        canvasEl.height = window.innerHeight * 2;
        canvasEl.style.width = window.innerWidth + "px";
        canvasEl.style.height = window.innerHeight + "px";
        canvasEl.getContext("2d").scale(2, 2);
      }

      function updateCoords(e) {
        pointerX = e.clientX || e.touches[0].clientX;
        pointerY = e.clientY || e.touches[0].clientY;
      }

      function setParticuleDirection(p) {
        var angle = (anime.random(0, 360) * Math.PI) / 180;
        var value = anime.random(50, 180);
        var radius = [-1, 1][anime.random(0, 1)] * value;
        return {
          x: p.x + radius * Math.cos(angle),
          y: p.y + radius * Math.sin(angle)
        };
      }

      function createParticule(x, y) {
        var p = {};
        p.x = x;
        p.y = y;
        p.color = colors[anime.random(0, colors.length - 1)];
        p.radius = anime.random(16, 32);
        p.endPos = setParticuleDirection(p);
        p.draw = function() {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI, true);
          ctx.fillStyle = p.color;
          ctx.fill();
        };
        return p;
      }

      function createCircle(x, y) {
        var p = {};
        p.x = x;
        p.y = y;
        p.color = "#FFF";
        p.radius = 0.1;
        p.alpha = 0.5;
        p.lineWidth = 6;
        p.draw = function() {
          ctx.globalAlpha = p.alpha;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI, true);
          ctx.lineWidth = p.lineWidth;
          ctx.strokeStyle = p.color;
          ctx.stroke();
          ctx.globalAlpha = 1;
        };
        return p;
      }

      function renderParticule(anim) {
        for (var i = 0; i < anim.animatables.length; i++) {
          anim.animatables[i].target.draw();
        }
      }

      function animateParticules(x, y) {
        var circle = createCircle(x, y);
        var particules = [];
        for (var i = 0; i < numberOfParticules; i++) {
          particules.push(createParticule(x, y));
        }
        anime
          .timeline()
          .add({
            targets: particules,
            x: function(p) {
              return p.endPos.x;
            },
            y: function(p) {
              return p.endPos.y;
            },
            radius: 0.1,
            duration: anime.random(1200, 1800),
            easing: "easeOutExpo",
            update: renderParticule
          })
          .add({
            targets: circle,
            radius: anime.random(80, 160),
            lineWidth: 0,
            alpha: {
              value: 0,
              easing: "linear",
              duration: anime.random(600, 800)
            },
            duration: anime.random(1200, 1800),
            easing: "easeOutExpo",
            update: renderParticule,
            offset: 0
          });
      }

      var render = anime({
        duration: Infinity,
        update: function() {
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
        }
      });

      document.addEventListener(
        tap,
        function(e) {
          window.human = true;
          render.play();
          updateCoords(e);
          animateParticules(pointerX, pointerY);
        },
        false
      );

      var centerX = window.innerWidth / 2;
      var centerY = window.innerHeight / 2;

      function autoClick() {
        if (window.human) return;
        animateParticules(
          anime.random(centerX - 50, centerX + 50),
          anime.random(centerY - 50, centerY + 50)
        );
        anime({ duration: 200 }).finished.then(autoClick);
      }

      autoClick();
      setCanvasSize();
      window.addEventListener("resize", setCanvasSize, false);
    </script-->
  </body>
</html>
